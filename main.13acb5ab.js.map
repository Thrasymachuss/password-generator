{"version":3,"sources":["main.js"],"names":["passwordLengthSetting","document","querySelector","inclusionSettings","querySelectorAll","maximums","minimums","includeDuplicates","exclusionSettings","includeOtherCharsSetting","otherCharsMin","otherCharsMax","otherCharsDuplicates","excludeOtherCharsSetting","beginWithLetterSetting","passwordOutputArea","generatePasswordBtn","userCanInclude","userCanExclude","letters","generatePassword","beginWithLetter","checked","passwordLength","valueAsNumber","otherExcludedChars","value","otherIncludedChars","allowedCharSets","mins","maxes","duplicates","counts","charsToExclude","forEach","setting","i","push","charsToInclude","split","char","j","includes","join","Set","hasAtLeastOneLetter","numberOfCharSets","length","NaN","test","sumArray","previousValue","currentValue","reduce","currentPasswordLength","returnPassword","firstIteration","selectCharFrom","charsStillRequired","difference","charsetsToRemove","unshift","index","splice","charset","tempCharset","selection","Math","floor","random","indexOfCharset","duplicateIndex","indexOf","newIndex","temp","addEventListener"],"mappings":"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","file":"main.13acb5ab.js","sourceRoot":"..\\src","sourcesContent":["// UI ELEMENTS\r\n\r\nconst passwordLengthSetting = document.querySelector(\"#password-length\");\r\n\r\nconst inclusionSettings = document.querySelectorAll(\".include\");    // Checkboxes for symbols, numbers, lowercase, uppercase\r\nconst maximums = document.querySelectorAll(\".max\");                 // Number input - max characters allowed for each character set\r\nconst minimums = document.querySelectorAll(\".min\");                 // Number input - min characters allowed for each set\r\nconst includeDuplicates = document.querySelectorAll(\".duplicates\"); // Checkboxes whether to allow duplicates for each set\r\n\r\nconst exclusionSettings = document.querySelectorAll(\".exclude\");    // Checkboxes for similar and ambiguous characters\r\n\r\n\r\n// The 'other' settings below are separted because they overwrite \r\n// the 'include' settings. Any characters included here will be \r\n// removed from other character sets.\r\nconst includeOtherCharsSetting = document.querySelector(\"#include-other\"); // Text input, not a checkbox\r\nconst otherCharsMin = document.querySelector(\"#other-min\");\r\nconst otherCharsMax = document.querySelector(\"#other-max\");\r\nconst otherCharsDuplicates = document.querySelector(\"#other-duplicates\");\r\n\r\n\r\n// This doesn't overwrite anything, but it is still separated from the \r\n// exclusionSettings variable because it is a text input rather than a checkbox.\r\nconst excludeOtherCharsSetting = document.querySelector(\"#exclude-other\");\r\n\r\n\r\nconst beginWithLetterSetting = document.querySelector(\"#begin-with-letter\");\r\n\r\nconst passwordOutputArea = document.querySelector(\"#new-password-area\");           \r\nconst generatePasswordBtn = document.querySelector(\"#generate-password-btn\");\r\n\r\n\r\n\r\n// CHARACTER SETS\r\n\r\n\r\n// Each string in these arrays corresponds to a checkbox.\r\nconst userCanInclude = [\r\n    \"!\\\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\r\n    \"1234567890\",\r\n    \"abcdefghijklmnopqrstuvwxyz\",\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\r\n];\r\n\r\nconst userCanExclude = [\r\n    \"iIl1lL|o0O\",               // Similar characters\r\n    \"{}[]()/\\\\'\\\"`~,;:.<>\",     // Ambiguous characters\r\n];\r\n\r\n\r\n// Only used to check whether a given character is a letter.\r\nconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; \r\n\r\n\r\n\r\n// GENERATE PASSWORD\r\n\r\n\r\n/**\r\n * Generate a password based on user specifications or return an error if input is invalid\r\n * @returns {String} A newly generated password OR an error message\r\n */\r\nfunction generatePassword() {\r\n\r\n    // Convert UI elements to usable values\r\n    const beginWithLetter = beginWithLetterSetting.checked;\r\n    const passwordLength = passwordLengthSetting.valueAsNumber;\r\n    const otherExcludedChars = excludeOtherCharsSetting.value;\r\n    const otherIncludedChars = includeOtherCharsSetting.value;\r\n\r\n\r\n    // Throw error if password length field is NaN or less than 1\r\n    if (!passwordLength || passwordLength < 1) {\r\n        return \"Error: Password length must be a number greater than 0.\";\r\n    }\r\n\r\n\r\n    // 2d array with every character specified by user. Separated by character set\r\n    let allowedCharSets = []; \r\n\r\n\r\n    // Each index in these arrays corresponds to the index\r\n    // of the associated character set in allowedCharSets\r\n\r\n    let mins = [];          // Int; minimum characters required from each charset\r\n    let maxes = [];         // Int; maximum characters allowed from each charset\r\n    let duplicates = [];    // Bool; true if duplicates are allowed, false if not allowed\r\n    let counts = [];        // Int; current number of characters in password from each charset\r\n\r\n    \r\n\r\n    // Chars to be removed from other charsets. Characters from otherIncludedChars\r\n    // will be reincluded in their own charset.\r\n    let charsToExclude = otherExcludedChars + otherIncludedChars;\r\n    exclusionSettings.forEach((setting, i) => {\r\n        if (setting.checked) {\r\n            charsToExclude += userCanExclude[i];\r\n        }\r\n    });\r\n\r\n\r\n    // Fill arrays with values\r\n    inclusionSettings.forEach((setting, i) => {\r\n\r\n        // If the user included a charset with a maximum above 0\r\n        if (setting.checked && maximums[i].value > 0) {\r\n\r\n            mins.push(minimums[i].valueAsNumber);\r\n            maxes.push(maximums[i].valueAsNumber);\r\n            duplicates.push(includeDuplicates[i].checked);\r\n            counts.push(0);\r\n            \r\n            // Change string to array so that allowedCharSets becomes a 2d array\r\n            let charsToInclude = userCanInclude[i].split('');\r\n            charsToInclude.forEach((char, j) => {\r\n\r\n                // Remove character if user either specified to exclude it or include it under 'other' characters\r\n                if (charsToExclude.includes(char)) {\r\n                    charsToInclude[j] = \"\";\r\n                }\r\n            });\r\n\r\n            // Remove empty strings in allowedCharSets\r\n            allowedCharSets.push(charsToInclude.join('').split(''));\r\n        }\r\n    });\r\n    \r\n\r\n\r\n    // If the user specified other characters to be included\r\n    if (otherIncludedChars && otherCharsMax.valueAsNumber > 0) {\r\n\r\n        // Remove duplicates and add characters to allowedCharSets\r\n        allowedCharSets.push([...new Set(otherIncludedChars.split(''))]);\r\n\r\n        mins.push(otherCharsMin.valueAsNumber);\r\n        maxes.push(otherCharsMax.valueAsNumber);\r\n        duplicates.push(otherCharsDuplicates.checked);\r\n        counts.push(0);\r\n    }\r\n\r\n    let hasAtLeastOneLetter = false; // To ensure that it is possible to start with a letter if beginWithLetter is true\r\n    let numberOfCharSets = allowedCharSets.length;\r\n\r\n    // Throw error if the user didn't select any charsets\r\n    if (!numberOfCharSets) {\r\n        return \"Error: You must select at least one character.\";\r\n    }\r\n\r\n    \r\n    // Checking that the min and max values are valid\r\n    for (let i = 0; i < numberOfCharSets; i++) {\r\n\r\n\r\n        // TODO: fix bug where user can specify maxes below 0\r\n        if (mins[i] === NaN || maxes[i] === NaN || mins[i] < 0 || maxes[i] < 0) {\r\n            return \"Error: Every min and max field must be a number greater than or equal to 0.\";\r\n        }\r\n\r\n        if (mins[i] > maxes[i]) {\r\n            return \"Error: At least one minimum is greater than its respective maximum.\";\r\n        }\r\n\r\n        if (mins[i] > allowedCharSets[i].length && !duplicates[i]) {\r\n            return \"Error: At least one character set with duplicates disabled has too few characters to meet its required minimum.\";\r\n        }\r\n\r\n        if (/[a-zA-Z]/.test(allowedCharSets[i].join(''))) {\r\n            hasAtLeastOneLetter = true;\r\n        }\r\n    }\r\n\r\n    if (beginWithLetter && !hasAtLeastOneLetter) {\r\n        return \"Error: Password must begin with a letter but no letters are selected.\";\r\n    }\r\n\r\n\r\n    const sumArray = (previousValue, currentValue) => previousValue + currentValue;\r\n    if ( maxes.reduce(sumArray) < passwordLength ) {\r\n        return \"Error: Total sum of maximums must be greater than or equal to password length.\";\r\n    }\r\n    if ( mins.reduce(sumArray) > passwordLength ) {\r\n        return \"Error: Total sum of minimums must be less than or equal to password length.\";\r\n    }\r\n\r\n\r\n\r\n    // Finished error checking; now we can start the loop\r\n    let returnPassword = \"\"; // Output string\r\n    let currentPasswordLength = 0; // Length of output string\r\n    let firstIteration = true; // Only used to select at least one letter if beginWithLetter is true\r\n\r\n\r\n    // While output string has fewer characters than specified password length\r\n    while (currentPasswordLength < passwordLength) {\r\n\r\n        let selectCharFrom = \"\"; // String that chars are randomly picked from\r\n        let charsStillRequired = 0; // Number of chars needed to meet all minimums\r\n\r\n        for (let i = 0; i < numberOfCharSets; i++) {\r\n\r\n            let difference = mins[i] - counts[i];\r\n\r\n            // If the current number of chars from any charset is less than its respective minimum\r\n            if (difference > 0) {\r\n\r\n                // Then add the difference to charsStillRequired\r\n                charsStillRequired += difference;\r\n            }\r\n        }\r\n\r\n        let charsetsToRemove = []; \r\n\r\n        // Remove charsets that have met their minimums if the number of chars \r\n        // left to add to the password is equal to (it should never be less than)\r\n        // the number of chars needed to meet all minimums\r\n        if ((passwordLength - returnPassword.length) <= charsStillRequired) {\r\n            for (let i = 0; i < numberOfCharSets; i++) {\r\n                if (counts[i] >= mins[i]) {\r\n                    charsetsToRemove.unshift(i);\r\n                }\r\n            }\r\n        }\r\n\r\n        charsetsToRemove.forEach((index) => {\r\n            mins.splice(index, 1);\r\n            maxes.splice(index, 1);\r\n            duplicates.splice(index, 1);\r\n            counts.splice(index, 1);\r\n            allowedCharSets.splice(index, 1);\r\n        });\r\n\r\n\r\n        // Compile allowedCharSets into the string to randomly pick a character from\r\n        allowedCharSets.forEach((charset) => {\r\n\r\n            // If we need to start with a letter, make sure we pick at least one letter\r\n            if (firstIteration && beginWithLetter) {\r\n                let tempCharset = [];\r\n\r\n                // For each charset, only include the letters in tempCharset\r\n                charset.forEach((char) => {\r\n                    if (letters.includes(char)) {\r\n                        tempCharset.push(char);\r\n                    }\r\n                });\r\n                selectCharFrom += tempCharset.join('');\r\n                return;\r\n            }\r\n\r\n            // If it isn't the first iteration or we don't need to start with a letter, just add the characters to the string\r\n            selectCharFrom += charset.join('');\r\n        });\r\n\r\n\r\n        // Throw error if we ever run out of valid characters\r\n        if (!selectCharFrom) {\r\n            return \"Error: Minimums, maximums, disallowing duplicates, and/or requiring a letter at the beginning prevented the generator from reaching the desired password length.\";\r\n        }\r\n\r\n\r\n    \r\n        let selection = selectCharFrom[Math.floor(Math.random()*selectCharFrom.length)]; // Randomly pick character\r\n        returnPassword += selection; // Add character to eventual output\r\n        currentPasswordLength = returnPassword.length; // Update length of output string\r\n\r\n\r\n\r\n        // Identify which charset the character was taken from\r\n        let indexOfCharset;\r\n        for (let i = 0; i < numberOfCharSets; i++) {\r\n            if (allowedCharSets[i].includes(selection)) {\r\n                counts[i]++;\r\n                indexOfCharset = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If duplicates are not allowed in the charset from which the selection was picked\r\n        if (!duplicates[indexOfCharset]) {\r\n\r\n            // Remove the character that was selected\r\n            let duplicateIndex = allowedCharSets[indexOfCharset].indexOf(selection);\r\n            allowedCharSets[indexOfCharset].splice(duplicateIndex, 1);\r\n        }\r\n\r\n\r\n        // Remove any character set that has reached its maximum\r\n        if (counts[indexOfCharset] >= maxes[indexOfCharset]) {\r\n            mins.splice(indexOfCharset, 1);\r\n            maxes.splice(indexOfCharset, 1);\r\n            duplicates.splice(indexOfCharset, 1);\r\n            counts.splice(indexOfCharset, 1);\r\n            allowedCharSets.splice(indexOfCharset, 1);\r\n        }\r\n\r\n\r\n        firstIteration = false;\r\n    }\r\n\r\n    // Randomly scramble output string with Fisher-Yates Shuffle\r\n    returnPassword = returnPassword.split(''); \r\n    for (let i = passwordLength - 1; i > 0; i--) {\r\n        newIndex = Math.floor(Math.random() * (i + 1));\r\n        let temp = returnPassword[i];\r\n        returnPassword[i] = returnPassword[newIndex];\r\n        returnPassword[newIndex] = temp;\r\n    }\r\n\r\n    // If the string must begin with a letter and it does not already\r\n    if (beginWithLetter && !letters.includes(returnPassword[0])) {\r\n\r\n        // Loop through string (currently array) until we find a letter\r\n        for (let i = 0; i < passwordLength; i++) {\r\n            if (letters.includes(returnPassword[i])) {\r\n\r\n                // Swap first character with letter\r\n                let temp = returnPassword[0];\r\n                returnPassword[0] = returnPassword[i];\r\n                returnPassword[i] = temp;\r\n            }\r\n        }\r\n    }\r\n    \r\n    returnPassword = returnPassword.join(''); // We want to return a string\r\n\r\n    return returnPassword;\r\n}\r\n\r\ngeneratePasswordBtn.addEventListener(\"click\", () => {passwordOutputArea.value = generatePassword();});\r\n"]}